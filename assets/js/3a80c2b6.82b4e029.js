"use strict";(self.webpackChunkapuntes=self.webpackChunkapuntes||[]).push([[442],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=p(a),m=r,b=c["".concat(l,".").concat(m)]||c[m]||u[m]||o;return a?n.createElement(b,s(s({ref:t},d),{},{components:a})):n.createElement(b,s({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=c;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},758:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const o={sidebar_position:3},s="Tipos de Datos",i={unversionedId:"primeros-pasos/tipos-de-datos",id:"primeros-pasos/tipos-de-datos",title:"Tipos de Datos",description:"Al solucionar un determinado problema mediante un algoritmo no es posible utilizar cualquier tipo de informaci\xf3n. Es decir, no siempre se puede utilizar cualquier tipo de dato.",source:"@site/docs/primeros-pasos/tipos-de-datos.md",sourceDirName:"primeros-pasos",slug:"/primeros-pasos/tipos-de-datos",permalink:"/primeros-pasos/tipos-de-datos",draft:!1,editUrl:"https://github.com/algo1camejo/apuntes/docs/primeros-pasos/tipos-de-datos.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Variables",permalink:"/primeros-pasos/variables"},next:{title:"Operadores",permalink:"/primeros-pasos/operadores"}},l={},p=[{value:"Clasificaci\xf3n",id:"clasificaci\xf3n",level:2},{value:"Simples",id:"simples",level:3},{value:"Ordinales",id:"ordinales",level:4},{value:"No Ordinales",id:"no-ordinales",level:4},{value:"Complejos (Estructurados)",id:"complejos-estructurados",level:3},{value:"Tipos de Datos en C",id:"tipos-de-datos-en-c",level:2},{value:"Char",id:"char",level:3},{value:"Enteros",id:"enteros",level:3},{value:"Booleano",id:"booleano",level:3},{value:"Coma Flotante (N\xfameros racionales)",id:"coma-flotante-n\xfameros-racionales",level:3}],d={toc:p};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tipos-de-datos"},"Tipos de Datos"),(0,r.kt)("p",null,"Al solucionar un determinado problema mediante un algoritmo no es posible utilizar cualquier tipo de informaci\xf3n. Es decir, no siempre se puede utilizar cualquier tipo de dato."),(0,r.kt)("p",null,"Un tipo de dato se puede definir como ",(0,r.kt)("strong",{parentName:"p"},'"Todos los valores posibles que una variable de ese tipo de dato puede tomar"'),"."),(0,r.kt)("h2",{id:"clasificaci\xf3n"},"Clasificaci\xf3n"),(0,r.kt)("h3",{id:"simples"},"Simples"),(0,r.kt)("p",null,"Estos a su vez se dividen en dos. "),(0,r.kt)("h4",{id:"ordinales"},"Ordinales"),(0,r.kt)("p",null,"Aquellos cuyos valores poseen sucesor y antecesor."),(0,r.kt)("p",null,"Por ejemplo, los n\xfameros enteros, se sabe que el antecesor de 5 siempre ser\xe1 el 4 y el sucesor el 6."),(0,r.kt)("h4",{id:"no-ordinales"},"No Ordinales"),(0,r.kt)("p",null,"Aquellos que no se puede determinar un sucesor o antecesor."),(0,r.kt)("p",null,"Por ejemplo, los n\xfameros reales, no se puede representar en la computaci\xf3n el n\xfamero que sucede al 0."),(0,r.kt)("h3",{id:"complejos-estructurados"},"Complejos (Estructurados)"),(0,r.kt)("p",null,"Estos se ven m\xe1s adelante."),(0,r.kt)("h2",{id:"tipos-de-datos-en-c"},"Tipos de Datos en C"),(0,r.kt)("h3",{id:"char"},"Char"),(0,r.kt)("p",null,"Las variables caracter contienen un \xfanico caracter y se almacenan en un byte de memoria (8 bits)."),(0,r.kt)("h3",{id:"enteros"},"Enteros"),(0,r.kt)("p",null,"Se pueden definir variables de tipo enteras de diferentes rangos."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"short")," : Entero con signo de 2 bytes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"int")," : Entero con signo de 4 bytes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"long")," : Entero con signo de 8 bytes.")),(0,r.kt)("p",null,"Mientras m\xe1s bytes tenga, el rango que puede representar es m\xe1s grande."),(0,r.kt)("p",null,"Los rangos de cada uno son:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"short")," : ","[-32,768, 32,767]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"int")," : ","[-2,147,483,648, 2,147,483,647]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"long")," : ","[-9,223,372,036,854,775,808, -9,223,372,036,854,775,808]")),(0,r.kt)("p",null,"Cabe aclarar que estos rangos son para arquitecturas de 64 bits, en arquitecturas de 32 bits el long y el int tienen el mismo rango (el de 4 bytes)."),(0,r.kt)("p",null,"Ahora, si solo se quiere utilizar los positivos se debe poner la palabra reservada ",(0,r.kt)("inlineCode",{parentName:"p"},"unsigned")," delante del tipo de dato, de la forma:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"unsigned short")," : ","[0, 65,535]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"unsigned int")," : ","[0, 4,294,967,295]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"unsigned long")," : ","[0, 18,446,744,073,709,551,615]")),(0,r.kt)("h3",{id:"booleano"},"Booleano"),(0,r.kt)("p",null,"Es un tipo de dato que solo admite dos valores posibles: ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," (verdadero) o ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," (falso)."),(0,r.kt)("p",null,"En C, cualquier expresi\xf3n que eval\xfaen cero se las considera falsas, y a todas las dem\xe1s, verdadera."),(0,r.kt)("p",null,"Pero para poder utilizar este tipo de dato se debe hacer inclusi\xf3n de una biblioteca."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#include <stdbool.h>\n")),(0,r.kt)("h3",{id:"coma-flotante-n\xfameros-racionales"},"Coma Flotante (N\xfameros racionales)"),(0,r.kt)("p",null,"Es una forma de notaci\xf3n cientifica usada en los microprocesadores con la se pueden representar n\xfameros racionales extremandamente grandes y peque\xf1os de manera muy eficiente y compacta, y se pueden realizar operaciones aritm\xe9ticas."),(0,r.kt)("p",null,"Es importante destacar que la comparaci\xf3n de flotantes puede resultar problem\xe1tica, debido a errores de redondeo, variables que se espera que sean iguales pueden tener valores ligeralmente distintos. Por esto mismo, se debe evitar la comparaci\xf3n desnuda (==)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Float")," : Este tipo de dato corresponde a la precisi\xf3n simple. Ocupa 4 bytes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"double")," : Este tipo de dato corresponde a la precisi\xf3n doble de 64 bits. Ocupa 8 bytes. Doble precisi\xf3n implica que los n\xfameros que puede representar pueden ser mucho m\xe1s chicos que los de un float o mucho m\xe1s grandes. "))),(0,r.kt)("p",null,"Cabe aclarar que en una arquitectura de 32 bits no hay diferencia entre usar float o double."))}u.isMDXComponent=!0}}]);