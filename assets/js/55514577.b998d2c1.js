"use strict";(self.webpackChunkapuntes=self.webpackChunkapuntes||[]).push([[284],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var d=n.createContext({}),s=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=s(e.components);return n.createElement(d.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,d=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=s(a),m=r,g=c["".concat(d,".").concat(m)]||c[m]||u[m]||l;return a?n.createElement(g,o(o({ref:t},p),{},{components:a})):n.createElement(g,o({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=c;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var s=2;s<l;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},6935:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const l={},o="Tipos b\xe1sicos de datos",i={unversionedId:"introduccion-lenguaje-c/tipos-de-datos",id:"introduccion-lenguaje-c/tipos-de-datos",title:"Tipos b\xe1sicos de datos",description:"El lenguaje C provee varios tipos b\xe1sicos de datos, la mayor\xeda de estos est\xe1n formados por uno de los cuatro especificadores de tipos aritm\xe9ticos b\xe1sicos del lenguaje C (char, int, float y double).",source:"@site/docs/introduccion-lenguaje-c/tipos-de-datos.md",sourceDirName:"introduccion-lenguaje-c",slug:"/introduccion-lenguaje-c/tipos-de-datos",permalink:"/introduccion-lenguaje-c/tipos-de-datos",draft:!1,editUrl:"https://github.com/algo1camejo/apuntes/docs/introduccion-lenguaje-c/tipos-de-datos.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Estructras de control",permalink:"/introduccion-lenguaje-c/estructuras-de-control"}},d={},s=[{value:"Tipo char",id:"tipo-char",level:3},{value:"Tipo de dato entero",id:"tipo-de-dato-entero",level:3},{value:"Tipo booleano",id:"tipo-booleano",level:3},{value:"Tipo de datos de coma flotante (floats)",id:"tipo-de-datos-de-coma-flotante-floats",level:3}],p={toc:s};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tipos-b\xe1sicos-de-datos"},"Tipos b\xe1sicos de datos"),(0,r.kt)("p",null,"El lenguaje C provee varios tipos b\xe1sicos de datos, la mayor\xeda de estos est\xe1n formados por uno de los cuatro especificadores de tipos aritm\xe9ticos b\xe1sicos del lenguaje C (char, int, float y double)."),(0,r.kt)("h3",{id:"tipo-char"},"Tipo char"),(0,r.kt)("p",null,"Las variables caracter (tipo char) contienen un \xfanico caracter y se almacenan en un byte de memoria (8 bits). Como se vi\xf3 el byte es una unidad de medida correspondiente a 8 bits, un bit (Binary Digit) es la m\xednima unidad de medida de la informaci\xf3n."),(0,r.kt)("p",null,"La cantidad de combinaciones posibles que se pueden obtener con j bits est\xe1 dada por la f\xf3rmula  $2^{j}$, por ende con un byte se pueden obtener $2^{8}$ combinaciones, es decir, 256 valores posibles."),(0,r.kt)("h3",{id:"tipo-de-dato-entero"},"Tipo de dato entero"),(0,r.kt)("p",null,"En este caso veremos los tipos de datos que surgen del especificador de tipo aritm\xe9tico b\xe1sico int y tambi\xe9n de la combinaci\xf3n de especificadores opcionales (signed, unsigned, short, long)."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Tipo"),(0,r.kt)("th",{parentName:"tr",align:null},"Tama\xf1o"),(0,r.kt)("th",{parentName:"tr",align:null},"M\xednimo"),(0,r.kt)("th",{parentName:"tr",align:null},"M\xe1ximo"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"char"),(0,r.kt)("td",{parentName:"tr",align:null},"1 byte"),(0,r.kt)("td",{parentName:"tr",align:null},"-128"),(0,r.kt)("td",{parentName:"tr",align:null},"127")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"unsigned char"),(0,r.kt)("td",{parentName:"tr",align:null},"1 byte"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"255")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"short"),(0,r.kt)("td",{parentName:"tr",align:null},"2 bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"-32,768"),(0,r.kt)("td",{parentName:"tr",align:null},"32,767")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"unsigned short"),(0,r.kt)("td",{parentName:"tr",align:null},"2 bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"65,535")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int"),(0,r.kt)("td",{parentName:"tr",align:null},"4 bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"-2,147,483,648"),(0,r.kt)("td",{parentName:"tr",align:null},"2,147,483,647")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"4 bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"4,294,967,295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"long"),(0,r.kt)("td",{parentName:"tr",align:null},"4 bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"-2,147,483,648"),(0,r.kt)("td",{parentName:"tr",align:null},"2,147,483,647")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"unsigned long"),(0,r.kt)("td",{parentName:"tr",align:null},"4 bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"4,294,967,295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int32","_","t"),(0,r.kt)("td",{parentName:"tr",align:null},"4 bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"-2,147,483,648"),(0,r.kt)("td",{parentName:"tr",align:null},"2,147,483,647")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int64","_","t"),(0,r.kt)("td",{parentName:"tr",align:null},"4 bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"-9,223,372,036,854,775,808"),(0,r.kt)("td",{parentName:"tr",align:null},"9,223,372,036,854,775,807")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uint64","_","t"),(0,r.kt)("td",{parentName:"tr",align:null},"8 bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"18,446,744,073,709,551,615")))),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Rangos de tipos de datos de C en una arquitectura de 32 bits")),(0,r.kt)("p",null,"Para saber c\xf3mo se obtienen los valores m\xe1ximos y m\xednimos de cada tipo de dato, hay que remitirse a la cantidad de combinaciones posibles seg\xfan la longitud en bytes del mismo.\nVale la pena destacar que los tipos de datos marcados como signed utilizan el bit m\xe1s significativo para almacenar el signo, un 1 corresponde a negativo y un 0 corresponde a positivo."),(0,r.kt)("h3",{id:"tipo-booleano"},"Tipo booleano"),(0,r.kt)("p",null,"El tipo de dato booleano se define como uno que s\xf3lo admite dos valores posibles: ",(0,r.kt)("em",{parentName:"p"},"true")," (verdadero) y ",(0,r.kt)("em",{parentName:"p"},"false")," (falso).\nEl lenguaje de programaci\xf3n C no incluye (por defecto) un tipo de dato booleano, en cambio, aquellas expresiones que eval\xfaen a 0 se las considera falsas, y a todas las dem\xe1s, verdaderas."),(0,r.kt)("p",null,"Es posible abstraerse de esta implementaci\xf3n poco intuitiva mediante la inclusi\xf3n de ",(0,r.kt)("inlineCode",{parentName:"p"},"stdbool.h"),", una biblioteca del est\xe1ndar, que permite declarar variables de tipo bool y asignarles ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," o ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("h3",{id:"tipo-de-datos-de-coma-flotante-floats"},"Tipo de datos de coma flotante (floats)"),(0,r.kt)("p",null,"La representaci\xf3n de coma flotante (en ingl\xe9s floating point) es una forma de notaci\xf3n cient\xedfica usada en los microprocesadores con la cual se pueden representar n\xfameros racionales extremadamente grandes y peque\xf1os de una manera muy eficiente y compacta, y con la que se pueden realizar operaciones aritm\xe9ticas.\nEs importante destacar que la comparaci\xf3n de flotantes puede resultar problem\xe1tica, debido a errores de redondeo, variables que se espera que sean iguales pueden tener valores ligeramente distintos."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Tipo"),(0,r.kt)("th",{parentName:"tr",align:null},"Tama\xf1o"),(0,r.kt)("th",{parentName:"tr",align:null},"Rango de valores"),(0,r.kt)("th",{parentName:"tr",align:null},"Precisi\xf3n"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"4 byte"),(0,r.kt)("td",{parentName:"tr",align:null},"1.2E-38 to 3.4E+38"),(0,r.kt)("td",{parentName:"tr",align:null},"6 lugares decimales")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"double"),(0,r.kt)("td",{parentName:"tr",align:null},"8 byte"),(0,r.kt)("td",{parentName:"tr",align:null},"2.3E-308 to 1.7E+308"),(0,r.kt)("td",{parentName:"tr",align:null},"15 lugares decimales")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"long double"),(0,r.kt)("td",{parentName:"tr",align:null},"10 byte"),(0,r.kt)("td",{parentName:"tr",align:null},"3.4E-4932 to 1.1E+4932"),(0,r.kt)("td",{parentName:"tr",align:null},"19 lugares decimales")))),(0,r.kt)("p",null,"El est\xe1ndar define formatos para la representaci\xf3n de n\xfameros en coma flotante (incluyendo el cero) y valores desnormalizados, as\xed como valores especiales como infinito y NaN (Not a Number).\nIEEE 754 especifica cuatro formatos para la representaci\xf3n de valores en coma flotante: precisi\xf3n simple (32 bits), precisi\xf3n doble (64 bits)."))}u.isMDXComponent=!0}}]);