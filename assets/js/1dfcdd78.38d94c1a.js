"use strict";(self.webpackChunkapuntes=self.webpackChunkapuntes||[]).push([[121],{3905:(e,a,n)=>{n.d(a,{Zo:()=>u,kt:()=>m});var r=n(7294);function t(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){t(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,r,t=function(e,a){if(null==e)return{};var n,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],a.indexOf(n)>=0||(t[n]=e[n]);return t}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(t[n]=e[n])}return t}var s=r.createContext({}),c=function(e){var a=r.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},u=function(e){var a=c(e.components);return r.createElement(s.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},p=r.forwardRef((function(e,a){var n=e.components,t=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=t,b=p["".concat(s,".").concat(m)]||p[m]||d[m]||i;return n?r.createElement(b,o(o({ref:a},u),{},{components:n})):r.createElement(b,o({ref:a},u))}));function m(e,a){var n=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l.mdxType="string"==typeof e?e:t,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4801:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(7462),t=(n(7294),n(3905));const i={sidebar_position:6},o="Buenas pr\xe1cticas de programaci\xf3n",l={unversionedId:"primeros-pasos/buenas-practicas",id:"primeros-pasos/buenas-practicas",title:"Buenas pr\xe1cticas de programaci\xf3n",description:"Nombres Descriptivos",source:"@site/docs/primeros-pasos/buenas-practicas.md",sourceDirName:"primeros-pasos",slug:"/primeros-pasos/buenas-practicas",permalink:"/primeros-pasos/buenas-practicas",draft:!1,editUrl:"https://github.com/algo1camejo/apuntes/docs/primeros-pasos/buenas-practicas.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Estructuras de Control",permalink:"/primeros-pasos/estructuras-de-control"}},s={},c=[{value:"Nombres Descriptivos",id:"nombres-descriptivos",level:2},{value:"Reglas para Poner Nombres",id:"reglas-para-poner-nombres",level:3},{value:"Declaraci\xf3n de Variables",id:"declaraci\xf3n-de-variables",level:2},{value:"Uso de Constantes",id:"uso-de-constantes",level:2},{value:"Inicializaci\xf3n de variables",id:"inicializaci\xf3n-de-variables",level:2},{value:"Emplear una sola convenci\xf3n",id:"emplear-una-sola-convenci\xf3n",level:2},{value:"Variables Globales",id:"variables-globales",level:2},{value:"Indentaci\xf3n",id:"indentaci\xf3n",level:2},{value:"Una instrucci\xf3n por l\xednea",id:"una-instrucci\xf3n-por-l\xednea",level:2},{value:"Usar par\xe9ntesis para cada operaci\xf3n l\xf3gica",id:"usar-par\xe9ntesis-para-cada-operaci\xf3n-l\xf3gica",level:2},{value:"Evitar comentarios redundantes en el c\xf3digo",id:"evitar-comentarios-redundantes-en-el-c\xf3digo",level:2},{value:"Modularizaci\xf3n: Divide y vencer\xe1s",id:"modularizaci\xf3n-divide-y-vencer\xe1s",level:2},{value:"Pre y Post Condiciones",id:"pre-y-post-condiciones",level:2},{value:"Ejemplo",id:"ejemplo",level:3},{value:"Procedimientos para interactuar con el usuario",id:"procedimientos-para-interactuar-con-el-usuario",level:2},{value:"No declarar variables de m\xe1s",id:"no-declarar-variables-de-m\xe1s",level:2},{value:"Cortar estructuras iterativas correctamente",id:"cortar-estructuras-iterativas-correctamente",level:2}],u={toc:c};function d(e){let{components:a,...n}=e;return(0,t.kt)("wrapper",(0,r.Z)({},u,n,{components:a,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"buenas-pr\xe1cticas-de-programaci\xf3n"},"Buenas pr\xe1cticas de programaci\xf3n"),(0,t.kt)("h2",{id:"nombres-descriptivos"},"Nombres Descriptivos"),(0,t.kt)("p",null,"Se recomienda usar nombres descriptivos, tanto para nombrar funciones como variables, ya que le aporta ",(0,t.kt)("strong",{parentName:"p"},"legibilidad y claridad")," al c\xf3digo. Esto se debe principalmente a que, en general, el c\xf3digo siempre va a ser le\xeddo por alguien que no lo escribi\xf3, por lo tanto, es importante que un tercero pueda entenderlo con facilidad. Ejemplos de estos casos es en trabajos grupales, cuando alguien tiene que revisar el c\xf3digo, o cuando volvemos a leer el c\xf3digo despu\xe9s de un tiempo."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Mala Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-c"},"#define ELEMENTO 'H'\n#define MAX 100\n\nbool funcion(int numero) {\n    return (numero % 2 == 0);\n}\n\nchar v[MAX];\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java"},"final char ELEMENTO = 'H';\nfinal int MAX = 100;\n\npublic bool funcion(int numero) {\n    return (numero % 2 == 0);\n}\n\nchar v[] = new char[MAX];\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"ELEMENTO = 'H'\nMAX = 100\n\ndef funcion(numero):\n    return (numero % 2 == 0)\n    \nv = \"\";\n")),(0,t.kt)("p",null,"Los nombres son demasiado ",(0,t.kt)("strong",{parentName:"p"},"gen\xe9ricos"),". ",(0,t.kt)("inlineCode",{parentName:"p"},"ELEMENTO")," puede ser cualquier elemento de la tabla peri\xf3dica (principalmente para alguien que no est\xe1 familiarizado con dichos elementos). Un nombre tan gen\xe9rico, ",(0,t.kt)("em",{parentName:"p"},"no permite determinar correctamente que representa"),".\nLo mismo ocurre con el nombre de la funci\xf3n y del vector. En el caso de la funci\xf3n, se deber\xeda identificar la misma con un nombre que indique una ",(0,t.kt)("strong",{parentName:"p"},"acci\xf3n at\xf3mica"),". En el caso de la variable, se podr\xeda identificar con el ",(0,t.kt)("strong",{parentName:"p"},"contenido")," que tendr\xe1 vector."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Buena Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-c"},"#define HIDROGENO 'H'\n#define MAX_LEGAJOS 100\n\nbool es_impar(int numero) {\n    return (numero % 2 == 0);\n}\n\nint legajos[MAX_LEGAJOS];\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java"},"final char HIDROGENO = 'H';\nfinal int MAX_LEGAJOS = 100;\n\npublic bool es_impar(int numero) {\n    return (numero % 2 == 0);\n}\n\nchar legajos[] = new char[MAX_LEGAJOS];\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"HIDROGENO = 'H'\nMAX_LEGAJOS = 100\n\ndef es_impar(numero):\n    return (numero % 2 == 0)\n    \nlegajos = \"\";\n")),(0,t.kt)("p",null,"Vale aclarar que es importante que los nombres sean autodescriptivos pero tampoco se debe exagerar en longitud. Por ejemplo, nombrar a la funci\xf3n como ",(0,t.kt)("inlineCode",{parentName:"p"},"funcion_que_calcula_si_un_numero_es_par")," har\xeda que sea una tortura escribirlo cada vez que sea necesario."),(0,t.kt)("h3",{id:"reglas-para-poner-nombres"},"Reglas para Poner Nombres"),(0,t.kt)("p",null,"Seg\xfan el libro Code Clean de Uncle Bob:"),(0,t.kt)("ol",null,(0,t.kt)("li",{parentName:"ol"},(0,t.kt)("strong",{parentName:"li"},"Nombres reveladores"),"\nNombrar sin que luego exista la necesidad de realizar aclaraciones en un comentario. Los nombres deben aportar significado a las variables. Un ejemplo de mala pr\xe1ctica seria:",(0,t.kt)("pre",{parentName:"li"},(0,t.kt)("code",{parentName:"pre"},"```c\nint d; // Cantidad de d\xedas transcurridos\n```\nSer\xeda mejor nombrar la variable como:\n```c\nint dias_transcurridos;\n```\nEl nombre no es muy largo y aporta significado.\n"))),(0,t.kt)("li",{parentName:"ol"},(0,t.kt)("strong",{parentName:"li"},"Evitar la desinformaci\xf3n"),"\nEl nombre de la variable no debe ayudar a la incomprensi\xf3n del c\xf3digo. Por ejemplo una variable booleana que se llame ",(0,t.kt)("inlineCode",{parentName:"li"},"verdadero")," introduce desinformaci\xf3n dentro del contexto del c\xf3digo fuente. Esto se puede ver m\xe1s claro vi\xe9ndolo en c\xf3digo:",(0,t.kt)("pre",{parentName:"li"},(0,t.kt)("code",{parentName:"pre"},"```C\n...\nbool verdadero;\nif(verdadero == false) { ... }\n```\nEn este caso, que la variable se llame `verdadero` pero que se este verificando si la misma es falsa se presta a confusiones. Ser\xeda mejor nombrar la variable indicando que es lo que se quiere verificar si es verdadero o falso. Por ejemplo, si esa variable indica si un n\xfamero es par o no, podr\xeda llamarse `es_impar`.\n"))),(0,t.kt)("li",{parentName:"ol"},(0,t.kt)("strong",{parentName:"li"},"Nombres distinguibles"),"\nA veces, hay dos variables o funciones de alguna manera relacionadas que debido a la restricci\xf3n de que se llamen igual, la opci\xf3n a la que uno se ve tentado es cambiar el nombre de una por alguna regla arbitraria. Por ejemplo:",(0,t.kt)("pre",{parentName:"li"},(0,t.kt)("code",{parentName:"pre",className:"language-C"},"int obtener_cuenta() {...}\nint obtener_cuentas() {...}\n")),"No se puede notar la diferencia entre una funci\xf3n u otra a trav\xe9s del nombre. Por lo tanto, se deber\xedan nombrar de manera distinta pero de forma tal que se pueda distinguir que hace una y que hace la otra. Por ejemplo:",(0,t.kt)("pre",{parentName:"li"},(0,t.kt)("code",{parentName:"pre",className:"language-C"},"int obtener_cuenta_corriente() {...}\nint obtener_cuenta_ahorro() {...}\n"))),(0,t.kt)("li",{parentName:"ol"},(0,t.kt)("strong",{parentName:"li"},"Nombres f\xe1ciles de buscar"),"\nEn la medida que sea posible, se deben evitar los nombres de una sola letra. Por ejemplo, si se intenta buscar una variable ",(0,t.kt)("inlineCode",{parentName:"li"},"int i")," en un programa medianamente grande, el motor de b\xfasqueda del editor se va a detener en cada ",(0,t.kt)("inlineCode",{parentName:"li"},"i")," que se haya escrito, lentizando la b\xfasqueda."),(0,t.kt)("li",{parentName:"ol"},(0,t.kt)("strong",{parentName:"li"},"No Te Hagas el Canchero"),"\nPriorizar la claridad ante la iron\xeda o comicidad, de manera que cualquier involucrado lo pueda entender y no solo quien lo program\xf3."),(0,t.kt)("li",{parentName:"ol"},(0,t.kt)("strong",{parentName:"li"},"Una Sola Palabra por Concepto"),'\nSe debe utilizar el mismo concepto en todo el c\xf3digo. Por ejemplo, si se utiliza la palabra "obtener_valor" como nombre de una funci\xf3n, no deber\xedan utilizarse sus sin\xf3nimos para el mismo concepto (p. ej. conseguir o adquirir). Esto quiere decir que si hay una funci\xf3n que quiere obtener una letra, se deber\xeda llamar "obtener_letra" y no elegir un sin\xf3nimo como "conseguir_letra".'),(0,t.kt)("li",{parentName:"ol"},(0,t.kt)("strong",{parentName:"li"},"Nombres pronunciables"),'\nLos nombres deben poder pronunciarse. Evitar trabalenguas, por ejemplo, en vez de nombrar una variable como "fch_de_pbl", es preferible un nombre m\xe1s claro como "fecha_publicacion".'),(0,t.kt)("li",{parentName:"ol"},(0,t.kt)("strong",{parentName:"li"},"Evitar los Nombres Gen\xe9ricos"),"\nLos nombres deben ser autodescriptivos. Los nombres gen\xe9ricos no reducen la complejidad del c\xf3digo fuente sino que la aumentan.")),(0,t.kt)("h2",{id:"declaraci\xf3n-de-variables"},"Declaraci\xf3n de Variables"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Se pueden declarar distintas variables de un mismo tipo en una l\xednea"),". Es recomendable aplicar esta pr\xe1ctica cuando las variables tienen el mismo uso (por ejemplo, \xedndices de iteraci\xf3n). Puede ser que en el caso de que se declaren variables que no tienen algo en com\xfan se entorpezca la lectura del c\xf3digo."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Mala Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"int i, j, numero1, numero2, suma, resta;\n")),(0,t.kt)("p",null,"Se puede observar que, por m\xe1s que las variables corresponden al\nmismo tipo de dato, no implica que su uso ser\xe1 el mismo."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Buena Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"int i, j;\nint numero1, numero2; \nint suma, resta;\n")),(0,t.kt)("p",null,"En este caso, se agrupan las variables seg\xfan el rol que cumplen en el c\xf3digo. Es mas informativo y prolijo."),(0,t.kt)("h2",{id:"uso-de-constantes"},"Uso de Constantes"),(0,t.kt)("p",null,"Las constantes y/o literales se deben declarar antes que las funciones. Como convenci\xf3n, sus nombres deben ir en may\xfasculas."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Mala Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"int main() {\n    ...\n    const int PI = 3.14;\n    const int GRAVEDAD = 9.8;\n    ...\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-Java"},"public class Main {\n    public static void main(String args[]) {\n        ...\n        final int PI = 3.14;\n        final int GRAVEDAD = 9.8;\n        ...\n    }\n}\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Buena Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"const int PI = 3.14;\nconst int GRAVEDAD = 9.8;\n    \nint main() {\n    ...\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-Java"},"public class Main {\n    final int PI = 3.14;\n    final int GRAVEDAD = 9.8;\n        \n    public static void main(String args[]) {\n        ...\n    }\n}\n")),(0,t.kt)("h2",{id:"inicializaci\xf3n-de-variables"},"Inicializaci\xf3n de variables"),(0,t.kt)("p",null,"Inicializar una variable previo a su uso, evitar\xe1 que se trabaje con basura, y como consecuencia, se evitar\xe1n errores de ejecuci\xf3n o de acceso a una posici\xf3n no asignada de memoria. Esto es principalmente importante cuando, por ejemplo, se trate de variables que se utilizar\xe1n como \xedndices de un vector o matriz, o acumuladores. "),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Mala Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},'int contador;\nfor(int i = 0; i < 10; i++) {\n    contador++;\n}\nprintf("%i", contador);\n')),(0,t.kt)("p",null,"El operador ",(0,t.kt)("inlineCode",{parentName:"p"},"++")," intentar\xe1 aumentar en una unidad el valor de la variable ",(0,t.kt)("inlineCode",{parentName:"p"},"contador"),", pero la variable inicialmente no contiene nada que se pueda aumentar, simplemente es basura. Como consecuencia, el resultado de este programa ser\xe1 indefinido."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Buena Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},'int contador = 0;\nfor(int i = 0; i < 10; i++) {\n    contador++;\n}\nprintf("%i", contador);\n')),(0,t.kt)("p",null,'En este caso, se imprimir\xe1 por pantalla "10".'),(0,t.kt)("h2",{id:"emplear-una-sola-convenci\xf3n"},"Emplear una sola convenci\xf3n"),(0,t.kt)("p",null,"Cuando se toma una convenci\xf3n respecto a algo, debe ser utilizada en todo el c\xf3digo para que el mismo sea coherente. Cuando se utilizan varias palabras para nombrar una variable, constante o funci\xf3n, ",(0,t.kt)("strong",{parentName:"p"},"camel case")," une esas palabras, sin ning\xfan espacio en blanco, y ",(0,t.kt)("em",{parentName:"p"},"delimita el comienzo de cada nueva palabra con una letra may\xfascula"),". Por el contrario, ",(0,t.kt)("strong",{parentName:"p"},"snake case")," utiliza un gui\xf3n bajo entre las palabras para crear una separaci\xf3n. Entonces, cualquiera que se decida usar, esta convenci\xf3n debe ser respetada a lo largo de todo el programa."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"// Snake Case\nint nombre_variable;\n// Camel Case\nint nombreVariable;\n")),(0,t.kt)("p",null,"Lo mismo ocurre con la apertura y cierre de llaves. Las convenciones que se pueden tomar, por ejemplo, son:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"int main() {\n    ...\n}\n// \xf3\nint main() \n{\n    ...\n}\n")),(0,t.kt)("p",null,"Como \xfaltimo ejemplo, tambi\xe9n se debe respetar una \xfanica convenci\xf3n cuando se trata de la estructura condicional ",(0,t.kt)("inlineCode",{parentName:"p"},"if"),":"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"if(condicion) {\n    ...    \n} else if(condicion) {\n    ...     \n} else {\n    ...     \n}\n// \xf3\nif(condicion) {\n    ...    \n} \nelse if(condicion) {\n    ...     \n} \nelse {\n    ...     \n}\n")),(0,t.kt)("p",null,"Como conclusi\xf3n, en cualquier caso que se deba tomar una convenci\xf3n, la que se decida usar se debe respetar a lo largo de todo el programa."),(0,t.kt)("h2",{id:"variables-globales"},"Variables Globales"),(0,t.kt)("p",null,"El uso de variables globales no es recomendable, ya que al ser parte del entorno global del programa dicha variable se puede modificar en cualquier parte del mismo. A su vez, todo el programa depender\xeda de ella y tambi\xe9n dificultar\xeda la lectura del c\xf3digo. "),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Mala Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"int resultado ;\nint sumar (int num1 , int num2 ) {\n    resultado = num1 + num2 ;\n    return resultado ;\n}\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Buena Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"int sumar (int num1 , int num2 ) {\n    int resultado = num1 + num2 ;\n    return resultado ;\n}\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Observaci\xf3n"),": en este curso est\xe1 PROHIBIDO usar variables globales."),(0,t.kt)("h2",{id:"indentaci\xf3n"},"Indentaci\xf3n"),(0,t.kt)("p",null,"Cuando se trata del cuerpo de una funci\xf3n o una estructura de control, se debe indentar el mismo. Respecto a estructuras de control, esto aplica a\xfan cuanod la sentencia es una sola (ya que en ese caso, a veces no se suelen usar llaves). Como toda buena pr\xe1ctica, aumenta la legibilidad del c\xf3digo."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Mala Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},'int suma = 0;\nwhile(suma < MAX_PERSONAS) {\nfor(int i = 0; i < MAX_PERSONAS; i++) {\nsuma = suma + i;\nprintf (" %d\\n" , i);\n}\n}\n')),(0,t.kt)("p",null,"Se puede ver que es dif\xedcil saber d\xf3nde comienzan las instrucciones para\nla estructura de control, como tambi\xe9n la totalidad del c\xf3digo. "),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Buena Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},'int suma = 0;\nwhile(suma < MAX_PERSONAS) {\n    for(int i = 0; i < MAX_PERSONAS; i++) {\n        suma = suma + i;\n        printf (" %d\\n" , i);\n    }\n}\n')),(0,t.kt)("h2",{id:"una-instrucci\xf3n-por-l\xednea"},"Una instrucci\xf3n por l\xednea"),(0,t.kt)("p",null,"Si se escribe la totalidad del programa en una sola l\xednea, el compilador no tendr\xe1 problema en compilarlo y ejecutarlo (es decir, tener m\xe1s de una instrucci\xf3n en una l\xednea, no traer\xeda problemas de compilaci\xf3n o ejecuci\xf3n). Se escribe una instrucci\xf3n por l\xednea para hacer el seguimiento del c\xf3digo de una manera m\xe1s sencilla."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Mala Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"for (int i = 0; i < MAX_PERSONAS; i++) { suma = suma + i; j = i + 1; }\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Buena Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"for (int i = 0; i < MAX_PERSONAS; i++) { \n    suma = suma + i; \n    j = i + 1; \n}\n")),(0,t.kt)("h2",{id:"usar-par\xe9ntesis-para-cada-operaci\xf3n-l\xf3gica"},"Usar par\xe9ntesis para cada operaci\xf3n l\xf3gica"),(0,t.kt)("p",null,"No s\xf3lo ser\xe1 m\xe1s clara la lectura para el programador, sino que tambi\xe9n para el compilador."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Mala Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"if(numero < MAX_PERSONAS && opcion == OPCION_SI ) { ... }\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Buena Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"if((numero < MAX_PERSONAS) && (opcion == OPCION_SI)) { ... }\n")),(0,t.kt)("h2",{id:"evitar-comentarios-redundantes-en-el-c\xf3digo"},"Evitar comentarios redundantes en el c\xf3digo"),(0,t.kt)("p",null,"Siempre que se cumplan las buenas pr\xe1cticas mencionadas anteriormente, no deber\xeda ser necesario aclarar que hace una l\xednea de c\xf3digo con un comentario. Por ejemplo:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},"int salario = 100000; // Se asigna el salario mensual a la variable 'salario'\n")),(0,t.kt)("p",null,"Ya es claro lo que realiza dicha l\xednea de c\xf3digo con tal solo leerlo. El comentario en este ejemplo, es redundante."),(0,t.kt)("h2",{id:"modularizaci\xf3n-divide-y-vencer\xe1s"},"Modularizaci\xf3n: Divide y vencer\xe1s"),(0,t.kt)("p",null,"Modularizar un programa con funciones sencillas no s\xf3lo brinda legibilidad al c\xf3digo, sino tambi\xe9n ayuda a evitar repetici\xf3n del mismo. Es decir, que podemos reciclar c\xf3digo."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Ejemplo")," "),(0,t.kt)("p",null,"Se quiere calcular aproximadamente la cantidad de basura que se tira por d\xeda en Hogwarts. Se sabe que en cada habitaci\xf3n de cada casa conviven 3 alumnos, que hay un total de cuatro casas (Gryffindor, Hufflepuff, Ravenclaw y Slytherin) y que cada alumno genera aproximadamente 500 gramos de basura por d\xeda. La cantidad de habitaciones ser\xe1n ingresadas por el usuario."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Mala Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},'int main() {\n    int slytherin, gryffindor, ravenclaw, hufflepuff;\n    int total_basura;\n\n    printf("Ingrese cantidad de habitaciones para Gryffindor \\n");\n    scanf("%d", &gryffindor);\n    printf("Ingrese cantidad de habitaciones para Hufflepuff \\n");\n    scanf("%d", &hufflepuff);\n    printf("Ingrese cantidad de habitaciones para Ravenclaw \\n") ;\n    scanf("%d", &ravenclaw);\n    printf("Ingrese cantidad de habitaciones para Slytherin \\n");\n    scanf("%d", &slytherin);\n\n    total_basura = (slytherin + gryffindor + ravenclaw + hufflepuff)*3*500;\n    printf("El total de basura generada por dia (gr/dia) en Hogwarts es: %d\\n", total_basura);\n    \n    return 0;\n}\n')),(0,t.kt)("p",null,"No solo que no hay uso de constantes, si no que se repite c\xf3digo."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Buena Pr\xe1ctica")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},'#define GRYF "Gryffindor"\n#define HUFF "Hufflepuff"\n#define RAVE "Ravenclaw"\n#define SLY "Slytherin"\n#define CANT_ALUMNOS 3\n#define CANT_BASURA 500\n\nvoid pedir_cantidad_habitaciones(int* habitaciones, char* nombre_casa) {\n    printf("Ingrese cantidad de habitaciones para %s\\n" , nombre_casa);\n    scanf("%d", habitaciones);\n}\n\nint sumar_habitaciones(int slytherin, int gryffindor, int ravenclaw, int hufflepuff) {\n    return slytherin + gryffindor + ravenclaw + hufflepuff ;\n}\n\nint calcular_total_basura(int total_habitaciones) {\n    return (CANT_ALUMNOS*CANT_BASURA*total_habitaciones);\n}\n\nint main() {\n    int total_habitaciones;\n    int slytherin, gryffindor, ravenclaw, hufflepuff;\n    int total_basura;\n\n    pedir_cantidad_habitaciones(&gryffindor, GRYFF);\n    pedir_cantidad_habitaciones(&hufflepuff, HUFF);\n    pedir_cantidad_habitaciones(&ravenclaw, RAVE);\n    pedir_cantidad_habitaciones(&slytherin, SLY);\n\n    total_habitaciones = sumar_habitaciones(slytherin, gryffindor, ravenclaw, hufflepuff);\n    total_basura = calcular_total_basura(total_habitaciones);\n\n    printf("El total de basura generada por dia (gr/dia) en Hogwarts es: %d\\n", total_basura);\n    return 0;\n}\n')),(0,t.kt)("p",null,'El c\xf3digo se lo dividi\xf3 en funciones sencillas e incluso m\xe1s "generales" (por ejemplo, ',(0,t.kt)("inlineCode",{parentName:"p"},"pedir_cantidad_habitaciones()")," se puede usar la misma funci\xf3n para luego escribir distintos textos), se declararon constantes tal como se explic\xf3 anteriormente y da lugar a que dichas funciones puedan usarse reiteradas veces dentro del programa."),(0,t.kt)("h2",{id:"pre-y-post-condiciones"},"Pre y Post Condiciones"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Precondiciones"),": son las condiciones que deben estar dadas para que una funci\xf3n funcione correctamente. En otras palabras, en que estado deben estar los par\xe1metros recibidos."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Postcondiciones"),": las condiciones sobre el estado en que quedan las variables y \xe9l o los valores de retorno. En otras palabras, c\xf3mo va a ser lo que se devuelve o qu\xe9 sucede con los par\xe1metros en caso de ser modificados."),(0,t.kt)("p",null,"Se utlizan para llevar una documentaci\xf3n precisa de cada funci\xf3n (o procedimiento), sin necesidad de aclarar o explicar que hace la misma exactamente. Esto es importante, principalmente en el caso en que se este trabajando con otras personas en un mismo c\xf3digo."),(0,t.kt)("h3",{id:"ejemplo"},"Ejemplo"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-C"},'/*\n * Precondiciones: la cantidad de estrellas debe ser un n\xfamero mayor a 0.\n * Postcondiciones: se muestra por consola las estrellas enumeradas.\n * /\nvoid listar_estrellas(int cantidad_estrellas) {\n    for(int i = 1; i <= cantidad_estrellas; i++) {\n        printf("Estrella n\xb0: %i\\n", i);\n    }\n}\n')),(0,t.kt)("h2",{id:"procedimientos-para-interactuar-con-el-usuario"},"Procedimientos para interactuar con el usuario"),(0,t.kt)("p",null,"Siempre que se necesite interactuar con el usuario, por ejemplo, pedirle que ingrese datos, o mostrar datos por pantalla, se deber\xeda realizar un ",(0,t.kt)("strong",{parentName:"p"},"procedimiento")," que se encargue de dicha funcionalidad. "),(0,t.kt)("h2",{id:"no-declarar-variables-de-m\xe1s"},"No declarar variables de m\xe1s"),(0,t.kt)("p",null,"No es necesario gastar memoria en declarar variables que no son necesarias o imprescindibles. "),(0,t.kt)("h2",{id:"cortar-estructuras-iterativas-correctamente"},"Cortar estructuras iterativas correctamente"),(0,t.kt)("p",null,"Las estructuras iterativas tienen una condici\xf3n de corte, la cual debe ser respetada y la \xfanica puerta de salida de dicha estructura. Usar instrucciones como ",(0,t.kt)("inlineCode",{parentName:"p"},"break")," o ",(0,t.kt)("inlineCode",{parentName:"p"},"return")," dentro de estructuras iterativas rompe con el flujo normal del algoritmo, obstruyendo la lectura y comprensi\xf3n del c\xf3digo."))}d.isMDXComponent=!0}}]);